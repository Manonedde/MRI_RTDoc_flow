#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This script is used to perform automatic quality control (autoQC) on the data
generated by the tractometry flow pipeline. The QC is based on the Interquartile Range (IQR) 
method and a priori knowledge of the data. 

The a priori knowledge is based on the following metrics:
- streamline_count : < 10
- volume : < 100
- mean_length : < 20 or > 200

The script will generate a summary of the number of subjects excluded for each bundle and metric, 
and the original dataframe with the QC status.

Script returns:
- df_autoqc.csv : Dataframe with the QC status.
- autoqc_symmary.csv : Summary of the number of subjects excluded for each bundle and metric.
- box_volume_bundle.html : Boxplot of the volume for each bundle before QC.
- box_mean_length_bundle.html : Boxplot of the mean length for each bundle before QC.
- box_streamline_count_bundle.html : Boxplot of the streamline count for each bundle before QC.

"""

import argparse
import os

import pandas as pd
import numpy as np
import plotly.express as px

from scilpy.io.utils import (add_overwrite_arg,
                             assert_inputs_exist)


custom_order_box = ['AC', 'PC', 'AF_Left', 'AF_Right', 'CC_Fr_1', 'CC_Fr_2', 
                    'CC_Oc', 'CC_Pa', 'CC_Pr_Po','CC_Te', 'CG_Left', 'CG_Right',
                    'CG_Left_An', 'CG_Right_An', 'CG_Left_Po', 'CG_Right_Po',
                    'CG_Left_curve', 'CG_Right_curve', 'FX_Right', 'FX_Left', 
                    'IFOF_Left', 'IFOF_Right', 'ILF_Left', 'ILF_Right', 'MdLF_Left',
                    'MdLF_Right', 'OR_ML_Left', 'OR_ML_Right', 'SLF_Left', 'SLF_Right',
                    'UF_Left', 'UF_Right', 'FAT_Left','FAT_Right', 'FPT_Left', 'FPT_Right',
                    'POPT_Left', 'POPT_Right', 'PYT_Left', 'PYT_Right','MCP', 'SCP_Left',
                    'SCP_Right','ICP_Left', 'ICP_Right',  'FPT_Left_Brainstem',
                    'FPT_Right_Brainstem', 'POPT_Left_Brainstem', 'POPT_Right_Brainstem',
                    'PYT_Left_Brainstem', 'PYT_Right_Brainstem']

custom_y_range = {"Volume": [0,100000], "Count": [0, 60000], "Length": [0, 220]}

custom_y_label = {"Volume": "Volume (mm3)", "Count": "Streamlines Count (N)", "Length": "Length (mm)"}


def find_outliers_apriori(df, metric, value_column='Value'):
   """
    Find outliers based on a priori knowledge of the data.
    By default, a priori metrics are : 
                streamline_count : < 20 or <10
                volume : < 100 or < 50
                Length mean : < 20 | > 200
                Length std == 0 : 'FAILED'
    Tags the outliers with 'Warning' and 'Failed', respectively.

    Inputs:
    df : pandas.DataFrame. Dataframe containing the data.
    metric : str. Name of the metric to find the outliers.
    value_column : str, optional. Name of the column containing the values.
                     By default is 'value'.

    Returns:
    df : pandas.DataFrame. Dataframe with the QC column updated with 'WARNING' for outliers.

   """
   tmp = df.loc[(df.Statistics != 'max') & (df.Statistics != 'min')]
   if metric == 'Volume':
      tmp.loc[(tmp[value_column] < 101), 'QC_bundles'] = 'Warning'
      tmp.loc[(tmp[value_column] < 51), 'QC_bundles'] = 'Failed'
   elif metric == 'Length':
      tmp.loc[(tmp.Statistics == 'mean') & (tmp[value_column] < 20), 'QC_bundles'] = 'Warning'
      tmp.loc[(tmp.Statistics == 'mean') & (tmp[value_column] > 200), 'QC_bundles'] = 'Warning'
      tmp.loc[(tmp.Statistics == 'std') & (tmp[value_column] == 0.0), 'QC_bundles'] = 'Failed'
   elif metric == 'Count':
      tmp.loc[(tmp[value_column] < 21), 'QC_bundles'] = 'Warning'
      tmp.loc[(tmp[value_column] < 11), 'QC_bundles'] = 'Failed'
   return tmp


def find_mean_outliers_IQR(df, threshold_iqr=2, value_column='Value'):
   
   """
   Find outliers based on the Interquartile Range (IQR) method.
   Tag the outliers with 'Warning'.

    Inputs:
    df : pandas.DataFrame. Dataframe containing the data.
    threshold_iqr : float, optional. Threshold to define the limits of the IQR method.
                    By default is 2.
    value_column : str, optional. Name of the column containing the values.
                     By default is 'value'.

    Returns:
    df : pandas.DataFrame. Dataframe with the QC column updated with 'WARNING' for outliers.

   """
   tmp = df.loc[(df.Statistics != 'min') & (df.Statistics != 'max') & (df.Statistics != 'std')]
   lower_quartile_q1 = np.percentile(tmp[value_column],25)
   upper_quartile_q3 = np.percentile(tmp[value_column],75)
   IQR=upper_quartile_q3-lower_quartile_q1
   lower_limit = lower_quartile_q1 - (threshold_iqr*IQR)
   upper_limit = upper_quartile_q3 + (threshold_iqr*IQR)
   if tmp.Measures.unique() == 'Count':
         lower_limit = 11
   if tmp.Measures.unique() == 'Volume':
         lower_limit = 50
   #print(tmp.Measures.unique(), lower_quartile_q1, upper_quartile_q3, IQR, lower_limit, upper_limit)
   tmp.loc[(tmp.Value < lower_limit) ,'QC_IQR'] = 'Warning'
   tmp.loc[(tmp.Value > upper_limit) ,'QC_IQR'] = 'Warning'
   
   return tmp


def plot_interactive_boxplot(df, x, y, color_code, slider_col, color_sequence, custom_y_range, 
                             cutsom_y_label, custom_x_order, title, 
                             font_size=14, template="plotly_white",
                             hoverdata=["Sid", "QC_global"]):
    """
    Plot an interactive boxplot using plotly express with slider.

    Inputs:
    df : pandas.DataFrame. Dataframe containing the data.
    x : str. Name of the column to plot on the x-axis.
    y : str. Name of the column to plot on the y-axis.
    color_code : str. Name of the column to color the boxplot.
    color_sequence : list. List of colors to use for the boxplot.
    custom_y_range : dict. Dictionary containing the custom y-axis range for each frame.
    cutsom_y_label : dict. Dictionary containing the custom y-axis label for each frame.
    title : str. Title of the plot.
    slider_col : str. Name of the column to use as slider.
    font_size : int, optional. Font size of the plot. By default is 14.
    template : str, optional. Template of the plot. By default is 'plotly_white'.
    hoverdata : list, optional. List of columns to show in the hover data. By default is ["Sid", "QC_global"].

    Returns:
    fig : plotly figure. Interactive
    """
    fig = px.box(df, x=x, y=y, color=color_code, color_discrete_sequence=color_sequence,
                 category_orders={x:custom_x_order}, title=title, hover_data=hoverdata,
                 boxmode="overlay", points='outliers', animation_frame=slider_col, 
                 template=template)
    
    # Update Y-axis Label and Range
    for f in fig.frames:
        if f.name in custom_y_range:
            f.layout.update(yaxis_range = custom_y_range[(f.name)])
            f.layout.update(yaxis_title = cutsom_y_label[(f.name)])

    fig.update_layout(title_x=0.5, title_y=1, font = dict(size = font_size), 
                      hoverlabel = dict(font_size = font_size), 
                      margin=dict(l=20, r=20, t=20, b=210))
    fig['layout']['updatemenus'][0]['pad']=dict(r= 10, t= 180)
    fig['layout']['sliders'][0]['pad']=dict(r= 10, t= 180,)

    return fig



def plot_interactive_histogram(df, x, y, color_code, slider_col, title, 
                               font_size=14, template="plotly_white",
                               custom_x_order=None):
    """
    Plot an interactive boxplot using plotly express with slider.

    Inputs:
    df : pandas.DataFrame. Dataframe containing the data.
    x : str. Name of the column to plot on the x-axis.
    y : str. Name of the column to plot on the y-axis.
    color_code : str. Name of the column to color the boxplot.
    color_sequence : list. List of colors to use for the boxplot.
    title : str. Title of the plot.
    slider_col : str. Name of the column to use as slider.
    font_size : int, optional. Font size of the plot. By default is 14.
    template : str, optional. Template of the plot. By default is 'plotly_white'.

    Returns:
    fig : plotly figure. Interactive
    """
    fig = px.histogram(df, x=x, y=y, color=color_code, title=title,
                       animation_frame=slider_col, template=template,
                       category_orders={x:custom_x_order})
    
    # Update Y-axis Label and Range
    for f in fig.frames:
        curr_min = df.loc[(df[slider_col] == f.name)]['Value'].min()
        curr_max = df.loc[(df[slider_col] == f.name)]['Value'].max()
        f.layout.update(yaxis_range = [curr_min, curr_max + (curr_max*0.05)])

    fig.update_layout(title_x=0.5, title_y=1, font = dict(size = font_size), 
                      hoverlabel = dict(font_size = font_size), 
                      margin=dict(l=10, r=10, t=10, b=210))
    fig['layout']['updatemenus'][0]['pad']=dict(r= 10, t= 180)
    fig['layout']['sliders'][0]['pad']=dict(r= 10, t= 180,)

    return fig


def _build_arg_parser():
    p = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
                                description=__doc__)

    p.add_argument('in_csv',
                   help='CSV File containing the csv average stats (.csv).')

    p.add_argument('--profile',
                   help='CSV File containing for the profile stats (.csv).')
    p.add_argument('--out_csv',
                   help='Output CSV filename for the stats (.csv).')
    p.add_argument('--out_dir',
                   help='Output directory to save CSV. \n'
                   'By default is current folder.')
    p.add_argument('--rbx_ver',
                   help='Add version of RBX flow.')    

    add_overwrite_arg(p)

    return p


def main():
    parser = _build_arg_parser()
    args = parser.parse_args()

    assert_inputs_exist(parser, args.in_csv)

    pd.options.mode.chained_assignment = None

    if args.out_dir is None:
        args.out_dir = './'

    # Load csv data
    df = pd.read_csv(args.in_csv)
    df[['Stats_level']] = 'average'
    if args.rbx_ver:
        df['rbx_version'] = args.rbx_ver

    if args.profile:
        pf = pd.read_csv(args.profile)
        pf[['Stats_level']] = 'profile'
        pf[['QC_bundles','QC_IQR']] = "Pass"
        if args.rbx_ver:
            pf['rbx_version'] = args.rbx_ver

    N_for_colors=len(df.Bundles.unique())

    length_full_data = len(df.Sid.unique())
    summary_data_bundle, summary_data_subject = [], []

    df[['QC_bundles','QC_IQR']] = "Pass"

    data_with_outliers = []
    print('Start QC process...')
    for bundle in df.Bundles.unique(): #['AC', 'AF_Left']:
        curr_bundle = df.loc[(df.Bundles == bundle)]

        # Identify outliers based on IQR method for DWI metrics
        for metric_dwi in curr_bundle.Measures.unique(): #curr_bundle[curr_bundle.Method != 'Streamlines'].Measures.unique()
            curr_measure = find_mean_outliers_IQR(curr_bundle.loc[(curr_bundle.Measures == metric_dwi)])
            outliers_warning_sid = curr_measure.loc[(curr_measure.QC_IQR == 'Warning')]['Sid'].unique()
            # Update the QC status for the DWI metric - Bundle
            for w_sid in outliers_warning_sid:
                curr_bundle.loc[(curr_bundle.Bundles == bundle) & (curr_bundle.Sid == w_sid),'QC_IQR'] = 'Warning'
                if args.profile:
                    pf.loc[(pf.Bundles == bundle) & (pf.Sid == w_sid), 'QC_IQR'] = 'Warning'

        # Identify outliers based on a priori knowledge for Bundles metrics
        tmp_df_bundles_outliers = []
        for metric in ['Volume','Length','Count']:
            curr_metric = find_outliers_apriori(curr_bundle.loc[(curr_bundle.Measures == metric)], metric)
            tmp_df_bundles_outliers.append(curr_metric)
        df_bundles_outliers = pd.concat(tmp_df_bundles_outliers[:])

        # Update the QC status for the bundle metric - Bundle
        metric_outliers_warning_sid = curr_metric.loc[(curr_metric.QC_bundles == 'Warning')]['Sid'].unique()
        for w_sid in metric_outliers_warning_sid:
            curr_bundle.loc[(curr_bundle.Bundles == bundle) & (curr_bundle.Sid == w_sid),'QC_bundles'] = 'Warning'
            if args.profile:
                pf.loc[(pf.Bundles == bundle) & (pf.Sid == w_sid), 'QC_bundles'] = 'Warning'

        # Harmonize all Bundle metrics QC status if Failed for Streamlines Count
        for subject in df_bundles_outliers.Sid.unique():
            if 'Failed' in df_bundles_outliers.loc[
                        (df_bundles_outliers.Sid == subject) & (df_bundles_outliers.Bundles == bundle) 
                        & (df_bundles_outliers.Measures == 'Count')]['QC_bundles'].unique().tolist():
                curr_bundle.loc[(curr_bundle.Sid == subject) & (curr_bundle.Bundles == bundle),'QC_bundles'] = 'Failed'
                if args.profile:
                    pf.loc[(pf.Bundles == bundle) & (pf.Sid == subject), 'QC_bundles'] = 'Failed'
        data_with_outliers.append(curr_bundle)

    # Concatenate the dataframes
    df_outliers = pd.concat(data_with_outliers[:])
    df_outliers = df_outliers.sort_values(['Sid','Bundles','Measures'])
    if args.profile:
        pf = pf.sort_values(['Sid','Bundles','Measures'])

    print('Start summary QC process...')
        # Build summary
    for bundle in df_outliers.Bundles.unique():
        curr_bundle = df_outliers.loc[(df_outliers.Bundles == bundle)]
        tmp_summary = pd.DataFrame([str(bundle),
                                    len(curr_bundle.query("QC_bundles == 'Warning'").Sid.unique()),
                                    len(curr_bundle.query("QC_bundles == 'Failed'").Sid.unique()),
                                    len(curr_bundle.query("QC_IQR == 'Warning'").Sid.unique())]).T
        tmp_summary.columns=['Bundle','Subjects_warning','Subjects_failed','Subjects_outliers_IQR']
        tmp_summary['Nsubjects'] = tmp_summary['Subjects_warning'] + tmp_summary['Subjects_failed']
        tmp_summary['Percent_population_bundles'] = tmp_summary['Nsubjects'] / length_full_data*100
        tmp_summary.drop('Nsubjects', axis=1, inplace=True)
        summary_data_bundle.append(tmp_summary)

    for sub in df_outliers.Sid.unique():
        curr_subject = df_outliers.loc[(df_outliers.Sid == sub)]
        tmp_summary = pd.DataFrame([str(sub), 
                                    len(curr_subject.query("QC_bundles == 'Warning'").Bundles.unique()),
                                    len(curr_subject.query("QC_bundles == 'Failed'").Bundles.unique()),
                                    len(curr_subject.query("QC_IQR == 'Warning'").Bundles.unique())]).T
        tmp_summary.columns=['Sid','Bundles_warning','Bundles_failed','Bundles_outliers_IQR']
        summary_data_subject.append(tmp_summary)

        df_outliers.loc[(df_outliers.Sid == sub),'N_bundles'] = len(curr_subject.Bundles.unique())
        if args.profile:
            pf.loc[(pf.Sid == sub), 'N_bundles'] = len(curr_subject.Bundles.unique())

    df_qc_bundles = pd.concat(summary_data_bundle[:])
    df_qc_subjects = pd.concat(summary_data_subject[:])

    print('Start generalize QC process...')
    # Mix QC IQR + Bundles conclusion into Global QC
    df_outliers['QC_global'] = df_outliers['QC_IQR']
    df_outliers.loc[(df_outliers.QC_bundles == 'Failed'), 'QC_global'] = 'Failed'
    if args.profile:
        pf['QC_global'] = pf['QC_IQR']
        pf.loc[(pf.QC_bundles == 'Failed'), 'QC_global'] = 'Failed'

    # Save the data
    if args.out_csv is not None:
        df_outliers.to_csv(os.path.join(args.out_dir, args.out_csv), index=False)
        if args.profile:
            args.out_csv = args.out_csv + '_profile.csv'
            pf.to_csv(os.path.join(args.out_dir, args.out_csv), index=False)
    else:
        outname = (os.path.splitext(os.path.basename(args.in_csv))[0]) + '_autoqc.csv'
        df_outliers.to_csv(os.path.join(args.out_dir,
                                        outname), index=False)
        if args.profile:
            outname = (os.path.splitext(os.path.basename(args.profile))[0]) + '_autoqc.csv'
            pf.to_csv(os.path.join(args.out_dir, outname), index=False)

    df_qc_bundles.to_csv(os.path.join(args.out_dir,
                                      'df_autoqc_bundle_symmary.csv'), index=False)
    df_qc_subjects.to_csv(os.path.join(args.out_dir,
                                      'df_autoqc_subject_symmary.csv'), index=False)
    
    print('Start plotting...')
    # Plot the data before QC
    bundles_colors = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 360, N_for_colors)]
    fig = plot_interactive_boxplot(df_outliers.query("Method == 'Streamlines'"), "Bundles",
                                   "Value", "Bundles","Measures", bundles_colors, custom_y_range, 
                                   custom_y_label, custom_order_box, 
                                   'Streamlines measures distribution')
    fig.write_html(os.path.join(args.out_dir,'box_streamline_measures_bundle.html'), auto_play=False)

    qc_bundle_long = df_qc_bundles.melt(id_vars="Bundle", var_name="QC", value_name="Value")
    fig = plot_interactive_histogram(qc_bundle_long, "Bundle", "Value", "Bundle", "QC",
                                     'Summary of QC status for each bundle', custom_x_order=custom_order_box)
    fig.write_html(os.path.join(args.out_dir,'box_bundle_by_qc_status.html'), auto_play=False)

    summary_colors = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 360, len(qc_bundle_long.QC.unique()))]
    fig = plot_interactive_histogram(qc_bundle_long, "QC", "Value", "QC", "Bundle",
                                     'Summary of QC status for each bundle', custom_x_order=custom_order_box)
    fig.write_html(os.path.join(args.out_dir,'box_qc_status_by_bundle.html'), auto_play=False)



if __name__ == '__main__':
    main()





