#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This script is used to perform automatic quality control (autoQC) on the data
generated by the tractometry flow pipeline. The QC is based on the Interquartile Range (IQR) 
method and a priori knowledge of the data. 

The a priori knowledge is based on the following metrics:
- streamline_count : < 10
- volume : < 100
- mean_length : < 20 or > 200

The script will generate a summary of the number of subjects excluded for each bundle and metric, 
and the original dataframe with the QC status.

Script returns:
- df_autoqc.csv : Dataframe with the QC status.
- autoqc_symmary.csv : Summary of the number of subjects excluded for each bundle and metric.
- box_volume_bundle.html : Boxplot of the volume for each bundle before QC.
- box_mean_length_bundle.html : Boxplot of the mean length for each bundle before QC.
- box_streamline_count_bundle.html : Boxplot of the streamline count for each bundle before QC.

"""

import argparse
import os

import pandas as pd
import numpy as np
import plotly.express as px

from scilpy.io.utils import (add_overwrite_arg,
                             assert_inputs_exist)


def find_outliers_apriori(df, metric, value_column='value',
                          qc_tag='WARNING'):
   """
    Find outliers based on a priori knowledge of the data.
    By default, a priori metrics are : 
                streamline_count : < 10
                volume : < 100
                mean_length : < 20 | > 200
    Inputs:
    df : pandas.DataFrame. Dataframe containing the data.
    metric : str. Name of the metric to find the outliers.
    value_column : str, optional. Name of the column containing the values.
                     By default is 'value'.
    qc_tag : str, optional. Tag to be used in the QC column for the outliers.
                By default is 'WARNING'.

    Returns:
    df : pandas.DataFrame. Dataframe with the QC column updated with 'WARNING' for outliers.

   """
   if metric == 'streamline_count':
      df.loc[(df[value_column] < 10), 'QC'] = qc_tag
   elif metric == 'volume':
      df.loc[(df[value_column] < 100), 'QC'] = qc_tag
   elif metric == 'mean_length':
      df.loc[(df[value_column] < 20) | (df[value_column] > 200), 'QC'] = qc_tag
   return df


def find_outliers_IQR(df, threshold_iqr=1.5, value_column='value',
                      qc_tag='WARNING'):
   """
   Find outliers based on the Interquartile Range (IQR) method.

    Inputs:
    df : pandas.DataFrame. Dataframe containing the data.
    threshold_iqr : float, optional. Threshold to define the limits of the IQR method.
                    By default is 1.5.
    value_column : str, optional. Name of the column containing the values.
                     By default is 'value'.
    qc_tag : str, optional. Tag to be used in the QC column for the outliers.
                By default is 'WARNING'.
    Returns:
    df : pandas.DataFrame. Dataframe with the QC column updated with 'WARNING' for outliers.

   """
   lower_quartile_q1 = np.percentile(df[value_column],25)
   upper_quartile_q3 = np.percentile(df[value_column],75)
   IQR=upper_quartile_q3-lower_quartile_q1
   lower_limit = lower_quartile_q1 - (threshold_iqr*IQR)
   upper_limit = upper_quartile_q3 + (threshold_iqr*IQR)
   df.loc[(df[value_column] < lower_limit) | (df[value_column] > upper_limit), 'QC'] = qc_tag
   return df


def _build_arg_parser():
    p = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
                                description=__doc__)

    p.add_argument('in_csv',
                   help='File(s) containing the csv stats (.csv).')

    p.add_argument('--out_csv',
                   help='Output CSV filename for the stats (.csv).')
    p.add_argument('--out_dir',
                   help='Output directory to save CSV. \n'
                   'By default is current folder.')
    

    add_overwrite_arg(p)

    return p


def main():
    parser = _build_arg_parser()
    args = parser.parse_args()

    assert_inputs_exist(parser, args.in_csv)

    pd.options.mode.chained_assignment = None

    if args.out_dir is None:
        args.out_dir = './'

    # Load csv data
    df = pd.read_csv(args.in_csv)
    df[['Stats_level']] = 'average'

    N_for_colors=len(df.roi.unique())
    set_colors = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 360, N_for_colors)]

    length_full_data = len(df.sid.unique())
    summary_data = []
    df_with_outliers = []

    for bundle in df.roi.unique():
        for metric in ['mean_length','volume','streamline_count']:
            curr_df = df.query("roi == @bundle & metrics == @metric")
            # check with a priori knowledge
            curr_df = find_outliers_apriori(curr_df, metric)
            # Check with IQR method
            curr_df = find_outliers_IQR(curr_df)

            # Build summary
            tmp_summary = pd.DataFrame([str(bundle), str(metric), len(curr_df.query("QC == 'WARNING'").sid.unique())]).T
            tmp_summary.columns=['bundle','metric','Nsubjects']
            tmp_summary['Percent_population'] = tmp_summary['Nsubjects'] / length_full_data*100

            # Append to the summary dataframe
            summary_data.append(tmp_summary)
            # Append to the dataframe after QC
            df_with_outliers.append(curr_df)

    # Concatenate the dataframes
    df_autoqc = pd.concat(df_with_outliers[:])
    df_autoqc.loc[df_autoqc.QC != 'WARNING', 'QC'] = 'PASS'
    df_summary= pd.concat(summary_data[:])

    # Save the data
    df_autoqc.to_csv(os.path.join(args.out_dir,
                                  'df_autoqc.csv'), index=False)
    df_summary.to_csv(os.path.join(args.out_dir,
                                  'autoqc_symmary.csv'), index=False)
    
    # Plot the data before QC
    fig = px.box(df.query("metrics == 'volume'"), x="roi", y="value", color="roi", 
                 color_discrete_sequence=set_colors, boxmode="overlay", hover_data=["sid"])
    fig.write_html(os.path.join(args.out_dir,'box_volume_bundle.html'))

    fig = px.box(df.query("metrics == 'mean_length'"), x="roi", y="value", color="roi", 
                 color_discrete_sequence=set_colors, boxmode="overlay", hover_data=["sid"])
    fig.write_html(os.path.join(args.out_dir,'box_mean_length_bundle.html'))

    fig = px.box(df.query("metrics == 'streamline_count'"), x="roi", y="value", color="roi", 
                 color_discrete_sequence=set_colors, boxmode="overlay", hover_data=["sid"])
    fig.write_html(os.path.join(args.out_dir,'box_streamline_count_bundle.html'))


if __name__ == '__main__':
    main()

